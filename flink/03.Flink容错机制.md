# 一、Flink一致性检查点

> ​		Flink是一个分布式的流处理引擎，而流处理的其中一个特点就是7X24 可用。那么，如何保障Flink作业的持续运行呢? Flink的内部会将应用状态(state)存储到本地内存或者嵌入式的kv数据库(RocksDB)中，由于采用的是分布式架构，Flink需要对本地生成的状态进行持久化存储，以避免因应用或者节点机器故障等原因导致数据的丢失，Flink是通过checkpoint(检查点)的方式将状态写入到远程的持久化存储，从而就可以实现不同语义的结果保障。
>
> ​		为了保证state容错，Flink提供了处理故障的措施，这种措施称之为checkpoint(一致性检查点)。checkpoint是Flink实现容错的核心功能，主要是**周期性地触发checkpoint，将state生成快照持久化到外部存储系统(比如HDFS) **。这样一来，如果Flink程序出现故障，那么就可以从上一次checkpoint中进行状态恢复，从而提供容错保障。另外，通过checkpoint机制，Flink可以实现Exactly-once语义(Flink内部的Exactly-once,关于端到端的exactly_once,Flink是通过两阶段提交协议实现的)。



## 1.1 状态一致性概述

​		当在分布式系统中引入状态时，自然也引入了一致性问题。

​		一致性实际上是"**正确性级别**"的另一种说法，也就是说**在成功处理故障并恢复之后得到的结果，与没有发生任何故障时得到的结果相比，前者到底有多正确**？举例来说，假设要对最近一小时登录的用户计数。在系统经历故障之后，计数结果是多少？如果有偏差，是有漏掉的计数还是重复计数？



在流处理中，一致性可以分为3个级别:

- **at-most-once(最多一次):** 

  这其实是没有正确性保障的委婉说法——故障发生之后，计数结果可能丢失。

- **at-least-once(至少一次):**

  这表示计数结果可能大于正确值，但绝不会小于正确值。也就是说，计数程序在发生故障后**可能多算**，但是**绝不会少算。**

- **exactly-once(严格变一次):**

  这指的是系统保证**在发生故障后得到的计数结果与正确值一致。**既不多算也不少算。**恰好处理一次是最严格的保证，也是最难实现的。**



​		Flink的一个重大价值在于，它**既**保证了**exactly-once**，**又**具有**低延迟和高吞吐**的处理能力。

## 1.2 端到端的状态一致性

​		端到端的一致性保证，意味着结果的正确性贯穿了整个流处理应用的始终；每一个组件都保证了它自己的一致性，整个端到端的一致性级别取决于所有组件中一致性最弱的组件。具体划分如下:

- source端

- - 需要外部源可重设数据的读取位置。
  - 目前我们使用的Kafka Source具有这种特性: **读取数据的时候可以指定offset**。

- flink内部

- - 依赖checkpoint机制

- sink端

​		需要保证从故障恢复时，数据不会重复写入外部系统. 有2种实现形式：幂等写入、事务性写入



# 二、Checkpoint

​		Flink是一个分布式数据处理系统，这种场景下，它需要处理各种异常，例如进程终止、机器故障、网络中断等。因为tasks在本地维护它们的state，Flink必须确保在出现故障的情况下，state不会丢失，并且保持一致性。

​		Flink具体如何保证exactly-once呢? 它使用一种被称为"检查点"（**checkpoint**）的特性，在出现故障时将系统重置回正确状态。下面通过简单的类比来解释检查点的作用。



## 制作一致性检查点

​		Flink的恢复机制**基于应用状态的一致检查点**。**有状态流应用的一致检查点，其实就是所有任务的状态，在某个时间点的一份拷贝（一份快照）；这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候**。

​	在为application做一个一致性检查点时，遵循的一个基本算法步骤如下：

​		（1）暂停所有输入流的消费

​		（2）等待所有未被处理的data完全被处理，表示所有tasks已经处理了它们所有的输入数据

​		（3）做检查点：复制每个task的state到一个远端持久性存储。在所有tasks完成了它们的副本后，检查点完成

​		（4）恢复消费输入流

<img src="D:\ware\doc\bigdata\flink\images\1654316632655-1838f6e4-cee6-4c7a-9479-ca9f6e213fa2.png" alt="image.png" style="zoom:80%;" />

​		此应用有一个source task，消费一个递增数的流，如1，2，3等等。流中的数据被分区到一个基数流，一个偶数流。在一个sum operator中，有两个task，分别用于累加基数与偶数。Source task 存储当前输入流的偏移量作为state。Sum task 将当前的累加和作为state并存储。上图中，在输入偏移量为5时，Flink做了一个检查点，此时两个task的累加和分别为6和9。

​		sum_even: 2+4=6

​		sum_odd: 1+3+5=9

## 从检查点恢复状态

![image.png](D:\ware\doc\bigdata\flink\images\1654316821519-efee6704-b34e-4fc6-b7da-01ab7f8c05fb.png)

​		在流的执行过程中，Flink定期为application的state做一致性检查点。在发生故障时，Flink使用最新的检查点，以一致性地还原application的状态并重新开始执行。下图展示了恢复的过程：

**step1：重启应用**

(重启后，起初流都是空的)

![image.png](D:\ware\doc\bigdata\flink\images\1654316830954-edc0b5b5-c269-439f-952f-57dbab4c80ba.png)

**step2：从 checkpoint 中读取状态，将状态重置**

![image.png](D:\ware\doc\bigdata\flink\images\1654316843257-7e7b12ff-0d05-4e6c-aa08-c268d09be826.png)

- (读取在远程仓库(Storage，这里的仓库指状态后端保存数据指定的三种方式之一)保存的状态)
- 从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同

**step3：开始消费并处理检查点到发生故障之间的所有数据**

![image.png](D:\ware\doc\bigdata\flink\images\1654316853026-a78253f5-b472-4d72-95f4-c1bfcfe97cd7.png)

**这种检查点的保存和恢复机制可以为应用程序状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置**

*（这里要求source源也能记录状态，回退到读取数据7的状态，kafka有相应的偏移指针能完成该操作）*

# 三、Flink的检查点算法

​		checkpoint机制是Flink可靠性的基石，可以**保证Flink集群在某个算子因为某些原因(如 异常退出)出现故障时，能够将整个应用流图的状态恢复到故障之前的某一状态，保证应用流图状态的一致性**。

​		Flink的checkpoint机制原理来自"Chandy-Lamport algorithm"算法(分布式快照算法)的一种变体: 异步 barrier 快照（asynchronous barrier snapshotting）。每个需要checkpoint的应用在启动时，Flink的JobManager为其创建一个 **CheckpointCoordinator**，CheckpointCoordinator全权负责本应用的快照制作。



## 理解Barrier

​		流的barrier是Flink的Checkpoint中的一个核心概念. 多个barrier被插入到数据流中, 然后作为数据流的一部分随着数据流动(有点类似于Watermark).这些barrier不会跨越流中的数据。

